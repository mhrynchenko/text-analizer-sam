"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addModuleFederationFiles = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
function addModuleFederationFiles(host, options, defaultRemoteManifest) {
    const templateVariables = {
        ...(0, devkit_1.names)(options.name),
        ...options,
        tmpl: '',
        remotes: defaultRemoteManifest.map(({ name, port }) => {
            return {
                ...(0, devkit_1.names)(name),
                port,
            };
        }),
    };
    // Module federation requires bootstrap code to be dynamically imported.
    // Renaming original entry file so we can use `import(./bootstrap)` in
    // new entry file.
    host.rename((0, path_1.join)(options.appProjectRoot, 'src/main.tsx'), (0, path_1.join)(options.appProjectRoot, 'src/bootstrap.tsx'));
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, `../files/common`), options.appProjectRoot, templateVariables);
    const pathToModuleFederationFiles = options.typescriptConfiguration
        ? 'module-federation-ts'
        : 'module-federation';
    // New entry file is created here.
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, `../files/${pathToModuleFederationFiles}`), options.appProjectRoot, templateVariables);
    if (options.typescriptConfiguration) {
        const pathToWebpackConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.js');
        const pathToWebpackProdConfig = (0, devkit_1.joinPathFragments)(options.appProjectRoot, 'webpack.config.prod.js');
        if (host.exists(pathToWebpackConfig)) {
            host.delete(pathToWebpackConfig);
        }
        if (host.exists(pathToWebpackProdConfig)) {
            host.delete(pathToWebpackProdConfig);
        }
    }
}
exports.addModuleFederationFiles = addModuleFederationFiles;
